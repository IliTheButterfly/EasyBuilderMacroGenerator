from __future__ import annotations
from enum import Enum
from collections import deque
from itertools import repeat
from typing import IO, Any, Callable, Generic, List, Literal, Optional, Set, TextIO, Tuple, TypeAlias, TypeVar, Union, overload

DT = TypeVar('DT')

dt = Literal['bool', 'unsigned char', 'char', 'unsigned short', 
             'short', 'unsigned int', 'int', 'unsigned long', 'long', 'float', 'double']

HEADER = """GENERATED CODE
This code was generated by a script.
See https://github.com/IliTheButterfly/EasyBuilderMacroGenerator"""


def deboolify(value:Optional[DT]) -> Union[DT, int]:
    if value is None:
        return None
    elif isinstance(value, bool):
        return 1 if value else 0
    return value

class Resource:
    ID_COUNT = 0
    def __init__(self, *resources:Resource):
        """Constructor
        
        Args:
            *resources (Resource): Sub resources
        """
        self.resources:Set[Resource] = set(filter(lambda x: isinstance(x, Resource), resources))
        self._id = Resource.ID_COUNT
        Resource.ID_COUNT += 1
    def process(self, macro:Macro) -> None:
        """Processes the resource

        Args:
            macro (Macro): The containing macro
        """
        for r in self.resources:
            if isinstance(r, Resource) and not r.__class__ is Resource:
                r.process(macro)
                
    def __hash__(self) -> int:
        return hash(self._id)
    
class STATEMENT(Resource):
    def __init__(self, *resources:Resource):
        super().__init__(resources)
        
    def __str__(self) -> str: ...

    def process(self, macro:Macro):
        super().process(macro)
        
    def bake(self, macro:Macro):
        """Bakes the statement. In other words, writes the statement to the macro buffer

        Args:
            macro (Macro): The containing macro
        """
        macro.write_raw(str(self))
        
    def __hash__(self):
        return super().__hash__()
        
class EMPTY(STATEMENT):
    """An empty line
    """
    def __init__(self):
        """An empty line
        """
        super().__init__()
        
    def __str__(self) -> str:
        return '\n'
    
    def __hash__(self):
        return super().__hash__()

class BASE_STATEMENT(STATEMENT):
    """A concrete implementation of a statement
    """
    def __init__(self, value:str=None):
        """A concrete implementation of a statement

        Args:
            value (str, optional): Literal value to forward to the macro. Defaults to None.
        """
        super().__init__()
        self._res = value
        
    def __str__(self) -> str:
        if self._res is None:
            return '\n'
        return self._res + '\n'
    
    def __hash__(self):
        return super().__hash__()

class COMMENT(STATEMENT):
    """A comment
    """
    def __init__(self, text:str):
        """A comment

        Args:
            text (str): The commented text
        """
        super().__init__()
        self.text = text
        
    def __str__(self) -> str:
        return ''.join([f'// {l}\n' for l in self.text.splitlines(False)])
    
    def __hash__(self):
        return super().__hash__()

class C_IF(STATEMENT):
    """Custom implementation of an `if`
    """
    def __init__(self, condition:Union[EXPRESSION, Variable[bool], VariableItem[bool]]):
        """Custom implementation of an `if`

        Args:
            condition (Union[EXPRESSION, Variable[bool], VariableItem[bool]]): The condition for the if
        """
        super().__init__()
        condition = deboolify(condition)
        if isinstance(condition, (Variable, VariableItem)):
            condition = condition.as_literal()
        self.condition = condition
        
    def __str__(self) -> str:
        return f'if {str(self.condition)} then\n'
    
    def process(self, macro: Macro):
        if isinstance(self.condition, Resource):
            self.condition.process(macro)
        super().process(macro)
    
    def bake(self, macro:Macro):
        super().bake(macro)
        macro._open_if()
        
    def __hash__(self):
        return super().__hash__()

class CONDITION_BLOCK(STATEMENT):
    """Base class for condition containers
    """
    def __init__(self, *content:STATEMENT):
        """Base class for condition containers
        
        Args:
            *content (STATEMENT): The body statements
        """
        super().__init__()
        self.content:List[STATEMENT] = list([*content])
    
    def __hash__(self):
        return super().__hash__()

class COMPLETED_CONTAINER(STATEMENT):
    """A completed condition block
    """
    def __init__(self, parent:CONDITION_BLOCK):
        super().__init__()
        self._parent = parent
        
    def process(self, macro: Macro):
        self._parent.process(macro)

    def bake(self, macro: Macro):
        self._parent.bake(macro)
        
    def __hash__(self):
        return super().__hash__()

class ELSE_CONTAINER(CONDITION_BLOCK):
    def __init__(self, parent:CONDITION_BLOCK):
        super().__init__(*parent.content)
        self._empty = True
        
    def __call__(self, *body:STATEMENT) -> COMPLETED_CONTAINER:
        self._empty = False
        self.content.append(C_ELSE())
        self.content.extend(body)
        self.content.append(C_END_IF())
        return COMPLETED_CONTAINER(self)
        
    def process(self, macro: Macro):
        for s in self.content:
            s.process(macro)
        super().process(macro)
        
    def bake(self, macro: Macro):
        for s in self.content:
            s.bake(macro)
        if self._empty:
            C_END_IF().bake(macro)
            
    def __hash__(self):
        return super().__hash__()

class ELIF_CONTAINER(CONDITION_BLOCK):
    def __init__(self, parent:CONDITION_BLOCK):
        super().__init__(*parent.content)
        self._parent = parent
        self._empty = True
        
    def __call__(self, *body:STATEMENT) -> IF_CONTAINER:
        self._empty = False
        self.content.extend(body)
        return IF_CONTAINER(self)
    
    def process(self, macro: Macro):
        for s in self.content:
            s.process(macro)
        super().process(macro)
        
    def bake(self, macro: Macro):
        for s in self.content:
            s.bake(macro)
        if self._empty:
            C_END_IF().bake(macro)

    def __hash__(self):
        return super().__hash__()

class IF_CONTAINER(CONDITION_BLOCK):
    def __init__(self, parent:CONDITION_BLOCK):
        super().__init__(*parent.content)
        self._parent = parent
        self._ends = True
        
    def ELSE(self) -> ELSE_CONTAINER:
        self._ends = False
        return ELSE_CONTAINER(self)
    
    def ELIF(self, condition:AnyValue) -> ELIF_CONTAINER:
        condition = deboolify(condition)
        self.content.append(C_ELIF(condition))
        return ELIF_CONTAINER(self)
    
    def process(self, macro: Macro):
        for s in self.content:
            s.process(macro)
        super().process(macro)
        
    def bake(self, macro: Macro):
        for s in self.content:
            s.bake(macro)
        if self._ends:
            C_END_IF().bake(macro)

    def __hash__(self):
        return super().__hash__()

class IF(CONDITION_BLOCK):
    """An `if` statement
    """
    def __init__(self, condition:EXPRESSION):
        """An `if` statement

        Args:
            condition (EXPRESSION): The condition for the if
        """
        condition = deboolify(condition)
        super().__init__(C_IF(condition))
        self._empty = True
        
    def __call__(self, *body:STATEMENT) -> IF_CONTAINER:
        self._empty = False
        self.content.extend(body)
        return IF_CONTAINER(self)
    
    def process(self, macro: Macro):
        for s in self.content:
            s.process(macro)
        super().process(macro)
        
    def bake(self, macro: Macro):
        for s in self.content:
            s.bake(macro)
        if self._empty:
            C_END_IF().bake(macro)
        
    def __hash__(self):
        return super().__hash__()
    
class C_ELSE(STATEMENT):
    """A custom `else` statement
    """
    def __init__(self):
        """A custom `else` statement
        """
        super().__init__()
    
    def __str__(self) -> str:
        return 'else\n'
    
    def bake(self, macro:Macro):
        macro._close_if()
        super().bake(macro)
        macro._open_if()
    
    def __hash__(self):
        return super().__hash__()

class C_ELIF(STATEMENT):
    """A custom `else if` statement
    """
    def __init__(self, condition:AnyValue):
        """A custom `else if` statement

        Args:
            condition (AnyValue): The condition for the elif
        """
        condition = deboolify(condition)
        if isinstance(condition, (Variable, VariableItem)):
            condition = condition.as_literal()
        super().__init__(condition)
        self.condition = condition
    
    def __str__(self) -> str:
        return f'else if {str(self.condition)} then\n'
    
    def process(self, macro: Macro):
        if isinstance(self.condition, Resource):
            self.condition.process(macro)
        super().process(macro)
    
    def bake(self, macro:Macro):
        macro._close_if()
        super().bake(macro)
        macro._open_if()
        
    def __hash__(self):
        return super().__hash__()

class C_END_IF(STATEMENT):
    """A custom implementation of the `end if`
    """
    def __init__(self):
        """A custom implementation of the `end if`
        """
        super().__init__()
    
    def __str__(self) -> str:
        return 'end if\n'
    
    def bake(self, macro:Macro):
        macro._close_if()
        super().bake(macro)
        
    def __hash__(self):
        return super().__hash__()

class BLOCK(STATEMENT):
    """A collection of statements
    """
    def __init__(self, *statements:STATEMENT):
        """A collection of statements
        
        Args:
            *statements (STATEMENT): The contained statements
        """
        super().__init__()
        self.statements:List[STATEMENT] = list(statements)
        
    def process(self, macro):
        super().process(macro)
        for statement in self.statements:
            statement.process(macro)
    
    def bake(self, macro):
        for s in self.statements:
            s.bake(macro)
            
    def __hash__(self):
        return super().__hash__()

class VARIABLE_BLOCK(STATEMENT):
    """Internal statement for defining variables
    """
    def __init__(self):
        super().__init__()
        
    def bake(self, macro: Macro):
        for v in macro.variables:
            macro.write_raw(v.declare(), '\n')
            
    def __hash__(self):
        return super().__hash__()

class BEGIN_MACRO(STATEMENT):
    """Internal statement for the macro start
    """
    def __init__(self):
        super().__init__()
    
    def __str__(self) -> str:
        return 'macro_command main()\n'
    
    def bake(self, macro:Macro):
        super().bake(macro)
        macro._open_macro()
        
    def __hash__(self):
        return super().__hash__()

class END_MACRO(STATEMENT):
    """Internal statement for the macro end
    """
    def __init__(self):
        super().__init__()
    
    def __str__(self) -> str:
        return 'end macro_command\n'
    
    def bake(self, macro:Macro):
        macro._close_macro()
        super().bake(macro)
        
    def __hash__(self):
        return super().__hash__()

class ASSIGNMENT(STATEMENT):
    """Internal statement for variable assignments
    """
    def __init__(self, var:Union[Variable[DT], VariableItem[DT]], value:Any):
        super().__init__()
        self.var = var
        self.value = deboolify(value)
        
    def __str__(self) -> str:
        return f'{self.var} = {str(self.value)}\n'

    def process(self, macro: Macro):
        self.var.process(macro)
        if isinstance(self.value, Resource):
            self.value.process(macro)
        super().process(macro)
        
    def __hash__(self):
        return super().__hash__()


class CALL(STATEMENT):
    """Statement to define function calls
    """
    def __init__(self, funcName: str, *params:Union[Variable, VariableItem, bool, int, float, str]):
        """Statement to define function calls

        Args:
            funcName (str): The name of the function
            *params (Union[Variable, VariableItem, bool, int, float, str]): The parameters for the function
        """
        super().__init__()
        self.funcName = funcName
        self.params:List[Union[Variable, VariableItem, bool, int, float, str]] = list([deboolify(p) for p in params])
    
    def __str__(self) -> str:
        return f'{self.funcName}({", ".join([str(p) for p in self.params])})\n'
    
    def process(self, macro: Macro):
        for p in self.params:
            if isinstance(p, Resource):
                p.process(macro)
        super().process(macro)
        
    def __hash__(self):
        return super().__hash__()

class RETURN(STATEMENT):
    """Return statement
    """
    def __init__(self, ret:Union[EXPRESSION, Variable, VariableItem, bool, int, float, str, None] = None):
        """Return statement

        Args:
            ret (Union[EXPRESSION, Variable, VariableItem, bool, int, float, str, None], optional): Return value. Defaults to None.
        """
        super().__init__()
        self.ret = deboolify(ret)
    
    def __str__(self) -> str:
        if self.ret is None:
            return 'return'
        return f'return {str(self.ret)}'

    def process(self, macro: Macro):
        if isinstance(self.ret, Resource):
            self.ret.process(macro)
        super().process(macro)
        
    def __hash__(self):
        return super().__hash__()

class BREAK(STATEMENT):
    """Break statement
    """
    def __init__(self):
        """Break statement
        """
        super().__init__()
        
    def __str__(self) -> str:
        return 'break'
    
    def __hash__(self):
        return super().__hash__()

class CONTINUE(STATEMENT):
    """Continue statement
    """
    def __init__(self):
        """Continue statement
        """
        super().__init__()
        
    def __str__(self) -> str:
        return 'continue'
    
    def __hash__(self):
        return super().__hash__()

class CASE_CONTENT(STATEMENT):
    def __init__(self, match:AnyValue, *body:STATEMENT):
        super().__init__(match, *body)
        self.match = deboolify(match)
        self.body = body
        self._end = False
        self._start = False
        self.expression:Optional[AnyValue] = None

    def bake(self, macro):
        if self._start:
            C_IF(self.expression == self.match).bake(macro)
        else:
            C_ELIF(self.expression == self.match).bake(macro)
            
        for s in self.body:
            s.bake(macro)
        if self._end:
            C_END_IF().bake(macro)
            
    def __hash__(self):
        return super().__hash__()

class CASE(Resource):
    """A single case for a `SWITCH`
    """
    def __init__(self, match:AnyValue):
        """A single case for a `SWITCH`
        
        Args:
            match (AnyValue): the value to match
        """
        self.match = deboolify(match)
        super().__init__()
    
    def __call__(self, *body:STATEMENT) -> CASE_CONTENT:
        res = CASE_CONTENT(self.match, *body)
        self.resources.add(res)
        return res
    
    def __hash__(self):
        return super().__hash__()
    
class SWITCH(Resource):
    """A series of `if/else if` that act similar to a switch case
    """
    def __init__(self, expression:AnyValue):
        """A series of `if/else if` that act similar to a switch case

        Args:
            expression (AnyValue): The expression to match for the cases
        """
        super().__init__(expression)
        self.expression = deboolify(expression)
    
    def __call__(self, *cases:CASE_CONTENT) -> BLOCK:
        """The content of the `SWITCH`
        
        Args:
            *cases (CASE_CONTENT): A series of `CASE(match)(...)`
        """
        cases = list(cases)
        cases[-1]._end = True
        cases[0]._start = True
        for c in cases:
            c.expression = self.expression
        return BLOCK(*cases)
    
    def __hash__(self):
        return super().__hash__()
        
    
class EXPRESSION(Resource):
    """Base class for expressions
    """
    def __init__(self, *exps:EXPRESSION):
        """Base class for expressions
        
        Args:
            *exps (EXPRESSION): Sub expressions
        """
        super().__init__(*exps)
    
    def __and__(self, other:Union[EXPRESSION, Variable[bool], VariableItem[bool]]) -> EXPRESSION:
        other = deboolify(other)
        if isinstance(other, (Variable, VariableItem)):
            other = other.as_literal()
        return AND(self, other)
    
    def __or__(self, other:Union[EXPRESSION, Variable[bool], VariableItem[bool]]) -> EXPRESSION:
        other = deboolify(other)
        if isinstance(other, (Variable, VariableItem)):
            other = other.as_literal()
        return OR(self, other)
    
    def __invert__(self) -> EXPRESSION:
        return NOT(self)
    
    @overload
    def __eq__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self} == {deboolify(o)}')
    
    def __eq__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self} == {str(o)}')
    
    @overload
    def __ne__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self} <> {deboolify(o)}')
    
    def __ne__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self} <> {str(o)}')
    
    @overload
    def __lt__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self} < {deboolify(o)}')
    
    def __lt__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self} < {str(o)}')

    @overload
    def __le__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self} <= {deboolify(o)}')
    
    def __le__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self} <= {str(o)}')
    
    @overload
    def __gt__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self} > {deboolify(o)}')
    
    def __gt__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self} > {str(o)}')
    
    @overload
    def __ge__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self} >= {deboolify(o)}')
    
    def __ge__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self} >= {str(o)}')
    
    def __and__(self, o:Union[EXPRESSION, Variable[bool], VariableItem[bool]]) -> AND:
        return AND(self, deboolify(o))
    
    def __or__(self, o:Union[EXPRESSION, Variable[bool], VariableItem[bool]]) -> OR:
        return OR(self, deboolify(o))
    
    def __invert__(self) -> NOT:
        return NOT(self)
    
    def __sub__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} - {str(deboolify(o))}')
        res.resources.add(self)
        if isinstance(o, Resource):
            res.resources.add(o)
        return res
    
    def __add__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} + {str(deboolify(o))}')
        res.resources.add(self)
        if isinstance(o, Resource):
            res.resources.add(o)
        return res
    
    def __mul__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} * {str(deboolify(o))}')
        res.resources.add(self)
        if isinstance(o, Resource):
            res.resources.add(o)
        return res
    
    def __truediv__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} / {str(deboolify(o))}')
        res.resources.add(self)
        if isinstance(o, Resource):
            res.resources.add(o)
        return res
    
    def __mod__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} % {str(deboolify(o))}')
        res.resources.add(self)
        if isinstance(o, Resource):
            res.resources.add(o)
        return res
    
    def __str__(self) -> str: ...
    
    def __hash__(self):
        return super().__hash__()
    
class EVAL(EXPRESSION):
    """A function that evaluates to a value
    """
    def __init__(self, funcName: str, *params:Union[Variable, VariableItem, bool, int, float, str]):
        """A function that evaluates to a value
        Args:
            funcName (str): The name of the function
            *params (Union[Variable, VariableItem, bool, int, float, str]): The parameters for the function
        """
        super().__init__()
        self.funcName = funcName
        self.params:List[Union[Variable, VariableItem, bool, int, float, str]] = list([deboolify(p) for p in params])
        for p in self.params:
            if isinstance(p, Resource):
                self.resources.add(p)
    
    def __str__(self) -> str:
        return f'{self.funcName}({", ".join([str(p) for p in self.params])})'
    
    def process(self, macro: Macro):
        for p in self.params:
            if isinstance(p, Resource):
                p.process(macro)
        super().process(macro)
        
    def __hash__(self):
        return super().__hash__()
    
class LITERAL(EXPRESSION):
    """A literal value
    """
    def __init__(self, literal:str):
        """A literal value

        Args:
            literal (str): The literal value. This value will be pasted as-is into the generated macro
        """
        super().__init__()
        self.literal = literal
        
    def __str__(self) -> str:
        return self.literal
    
    def __repr__(self):
        return f"[{self.literal}]"
    
    def __hash__(self):
        return super().__hash__()
    
class NOT(EXPRESSION):
    def __init__(self, expression:EXPRESSION):
        super().__init__(expression)
        self.expression = expression.as_literal() if isinstance(expression, (Variable, VariableItem)) else expression
        
    def __invert__(self) -> EXPRESSION:
        return self.expression
        
    def __str__(self) -> str:
        return f'(not {self.expression})'
    
    def __repr__(self):
        return f'NOT [{repr(self.expression)}]'
    
    def __hash__(self):
        return super().__hash__()
    
class OR(EXPRESSION):
    def __init__(self, *expressions:EXPRESSION):
        super().__init__(*expressions)
        self._expressions:List[EXPRESSION] = [*[(e.as_literal() if isinstance(e, (Variable, VariableItem)) else e) for e in expressions]]
    
    def __or__(self, other:Union[EXPRESSION, Variable[bool], VariableItem[bool]]) -> OR:
        other = deboolify(other)
        if isinstance(other, (Variable, VariableItem)):
            other = other.as_literal()
        if isinstance(other, OR):
            return OR(*self._expressions, *other._expressions)
        return super().__or__(self, other)
    
    def append(self, *expressions:EXPRESSION):
        self._expressions.extend(expressions)
        self.resources.update(expressions)
        
    def __str__(self):
        return f'({" or ".join([str(e) for e in self._expressions])})'
        
    def __repr__(self):
        return f'[{" OR ".join([repr(e) for e in self._expressions])}]'
    
    def __hash__(self):
        return super().__hash__()
        
class AND(EXPRESSION):
    def __init__(self, *expressions:Union[EXPRESSION, Variable[bool], VariableItem[bool]]):
        super().__init__(*expressions)
        self._expressions:List[EXPRESSION] = [*[(e.as_literal() if isinstance(e, (Variable, VariableItem)) else e) for e in expressions]]
        
    def __and__(self, other:EXPRESSION) -> AND:
        other = deboolify(other)
        if isinstance(other, (Variable, VariableItem)):
            other = other.as_literal()
        if isinstance(other, AND):
            return AND(*self._expressions, *other._expressions)
        return super().__and__(other)
        
    def append(self, *expressions:EXPRESSION):
        self._expressions.extend(expressions)
        self.resources.update(expressions)
        
    def __str__(self):
        return f'({" and ".join([str(e) for e in self._expressions])})'
        
    def __repr__(self):
        return f'[{" AND ".join([repr(e) for e in self._expressions])}]'
    
    def __hash__(self):
        return super().__hash__()

class Variable(Resource, Generic[DT]):
    """Defines a variable
    """
    def __init__(self, name:str, dtype:dt, default:DT=None):
        """Defines a variable

        Args:
            name (str): The name of the variable
            dtype (dt): The data type
            default (DT, optional): The default value. Defaults to None.
        """
        Resource.__init__(self)
        self.name = name
        self.dtype = dtype
        self.default = deboolify(default)
        
    def process(self, macro:Macro) -> None:
        Resource.process(self, macro)
        macro.add_variable(self)
        
    def as_literal(self) -> LITERAL:
        res = LITERAL(str(self))
        res.resources.add(self)
        return res
        
    def declare(self) -> str:
        if self.default is None:
            return f'{self.dtype} {self.name}'
        return f'{self.dtype} {self.name} = {self.default}'
    
    @overload
    def __eq__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.name} == {deboolify(o)}')
    
    def __eq__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self.name} == {str(o)}')
    
    @overload
    def __ne__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.name} <> {deboolify(o)}')
    
    def __ne__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self.name} <> {str(o)}')
    
    @overload
    def __lt__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.name} < {deboolify(o)}')
    
    def __lt__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self.name} < {str(o)}')

    @overload
    def __le__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.name} <= {deboolify(o)}')
    
    def __le__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self.name} <= {str(o)}')
    
    @overload
    def __gt__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.name} > {deboolify(o)}')
    
    def __gt__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self.name} > {str(o)}')
    
    @overload
    def __ge__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.name} >= {deboolify(o)}')
    
    def __ge__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self.name} >= {str(o)}')
    
    def __and__(self, o:Union[EXPRESSION, Variable[bool], VariableItem[bool]]) -> AND:
        return AND(self, o)
    
    def __or__(self, o:Union[EXPRESSION, Variable[bool], VariableItem[bool]]) -> OR:
        return OR(self, o)
    
    def __invert__(self) -> NOT:
        return NOT(self)
    
    def __sub__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} - {str(deboolify(o))}')
        res.resources.add(self)
        if isinstance(o, Resource):
            res.resources.add(o)
        return res
    
    def __add__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} + {str(deboolify(o))}')
        res.resources.add(self)
        if isinstance(o, Resource):
            res.resources.add(o)
        return res
    
    def __mul__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} * {str(deboolify(o))}')
        res.resources.add(self)
        if isinstance(o, Resource):
            res.resources.add(o)
        return res
    
    def __truediv__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} / {str(deboolify(o))}')
        res.resources.add(self)
        if isinstance(o, Resource):
            res.resources.add(o)
        return res
    
    def __mod__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} % {str(deboolify(o))}')
        res.resources.add(self)
        if isinstance(o, Resource):
            res.resources.add(o)
        return res

    def set(self, o:Union[Variable, VariableItem, EXPRESSION, bool, int, float, str]) -> ASSIGNMENT:
        return ASSIGNMENT(self, deboolify(o))

    def __hash__(self) -> int:
        return self.name.__hash__()
    
    def __str__(self) -> str:
        return self.name
    

class VariableItem(Resource, Generic[DT]):
    def __init__(self, array:VariableArray[DT], index:Union[EXPRESSION, Variable[int], VariableItem[int], int]):
        Resource.__init__(self, array)
        self.array = array
        self.index = index
        if isinstance(self.index, Resource):
            self.resources.add(self.index)
        
    def process(self, macro:Macro) -> None:
        Resource.process(self, macro)
        macro.add_variable(self.array)
        
    def as_literal(self) -> LITERAL:
        res = LITERAL(str(self))
        res.resources.add(self)
        return res
        
    @overload
    def __eq__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.array.name} == {deboolify(o)}')
    
    def __eq__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self.array.name} == {str(o)}')
    
    @overload
    def __ne__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.array.name} <> {deboolify(o)}')
    
    def __ne__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self.array.name} <> {str(o)}')
    
    @overload
    def __lt__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.array.name} < {deboolify(o)}')
    
    def __lt__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self.array.name} < {str(o)}')

    @overload
    def __le__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.array.name} <= {deboolify(o)}')
    
    def __le__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self.array.name} <= {str(o)}')
    
    @overload
    def __gt__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.array.name} > {deboolify(o)}')
    
    def __gt__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self.array.name} > {str(o)}')
    
    @overload
    def __ge__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.array.name} >= {deboolify(o)}')
    
    def __ge__(self, o:Union[Variable, VariableItem, EXPRESSION]) -> LITERAL:
        self.resources.add(o)
        return LITERAL(f'{self.array.name} >= {str(o)}')
    
    def __and__(self, o:Union[EXPRESSION, VariableItem[bool], Variable[bool]]) -> AND:
        return AND(self, o)
    
    def __or__(self, o:Union[EXPRESSION, VariableItem[bool], Variable[bool]]) -> OR:
        return OR(self, o)
    
    def __invert__(self) -> NOT:
        return NOT(self)
    
    def __sub__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} - {str(deboolify(o))}')
        res.resources.add(self)
        if isinstance(o, Resource):
            res.resources.add(o)
        return res
    
    def __add__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} + {str(deboolify(o))}')
        res.resources.add(self)
        if isinstance(o, Resource):
            res.resources.add(o)
        return res
    
    def __mul__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} * {str(deboolify(o))}')
        res.resources.add(self)
        if isinstance(o, Resource):
            res.resources.add(o)
        return res
    
    def __truediv__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} / {str(deboolify(o))}')
        res.resources.add(self)
        if isinstance(o, Resource):
            res.resources.add(o)
        return res
    
    def __mod__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} % {str(deboolify(o))}')
        res.resources.add(self)
        if isinstance(o, Resource):
            res.resources.add(o)
        return res

    def set(self, o:AnyValue) -> ASSIGNMENT:
        return ASSIGNMENT(self, deboolify(o))

    def __str__(self) -> str:
        return f"{self.array.name}[{str(self.index)}]"
    
    def __hash__(self):
        return hash(str(self))
    
class VariableArray(Resource, Generic[DT]):
    def __init__(self, name:str, dtype:dt, size:int, default:Optional[List[DT]]=None):
        Resource.__init__(self)
        self.name = name
        self.dtype = dtype
        self.size = size
        # TODO Add size check
        if default is not None:
            for i in range(len(default)):
                default[i] = deboolify(default[i])
        self.default = default
    
    def process(self, macro:Macro) -> None:
        Resource.process(self, macro)
        macro.add_variable(self)
        
    def as_literal(self) -> LITERAL:
        res = LITERAL(str(self))
        res.resources.add(self)
        return res
        
    def declare(self) -> str:
        if self.default is None:
            return f'{self.dtype} {self.name}[{self.size}]'
        return f'{self.dtype} {self.name}[{self.size}] = ' + '{ ' + ", ".join(self.default) + ' }'

    def __getitem__(self, index:Union[Variable[int], VariableItem[int], EXPRESSION, int]) -> VariableItem[DT]:
        if isinstance(index, int) and index > self.size:
            raise IndexError(f"Index {index} out of range, must be between 0 and {self.size - 1}")
        return VariableItem[DT](self, index)
    
    def __setitem__(self, index:Union[Variable[int], VariableItem[int], EXPRESSION, int], o:Union[Variable, VariableItem, EXPRESSION, bool, int, float, str]) -> ASSIGNMENT:
        if isinstance(index, int) and (index < 0 or index > self.size):
            raise IndexError(f"Index {index} out of range, must be between 0 and {self.size - 1}")
        return VariableItem[DT](self, index).set(o)
        
    def __hash__(self) -> int:
        return self.name.__hash__()
    
    def __str__(self) -> str:
        return self.name


def vuchar(name:str, default:int = None) -> Variable[int]: return Variable(name, 'unsigned char', default)
def vchar(name:str, default:int = None) -> Variable[int]: return Variable(name, 'char', default)
def vushort(name:str, default:int = None) -> Variable[int]: return Variable(name, 'unsigned short', default)
def vshort(name:str, default:int = None) -> Variable[int]: return Variable(name, 'short', default)
def vuint(name:str, default:int = None) -> Variable[int]: return Variable(name, 'unsigned int', default)
def vint(name:str, default:int = None) -> Variable[int]: return Variable(name, 'int', default)
def vulong(name:str, default:int = None) -> Variable[int]: return Variable(name, 'unsigned long', default)
def vlong(name:str, default:int = None) -> Variable[int]: return Variable(name, 'long', default)
def vbool(name:str, default:bool = None) -> Variable[bool]: return Variable(name, 'bool', default)
def vfloat(name:str, default:float = None) -> Variable[float]: return Variable(name, 'float', default)
def vdouble(name:str, default:float = None) -> Variable[float]: return Variable(name, 'double', default)

def vuchar_arr(name:str, size:int, default:Optional[List[int]] = None) -> VariableArray[int]: return VariableArray(name, 'unsigned char', size, default)
def vchar_arr(name:str, size:int, default:Optional[List[int]] = None) -> VariableArray[int]: return VariableArray(name, 'char', size, default)
def vushort_arr(name:str, size:int, default:Optional[List[int]] = None) -> VariableArray[int]: return VariableArray(name, 'unsigned short', size, default)
def vshort_arr(name:str, size:int, default:Optional[List[int]] = None) -> VariableArray[int]: return VariableArray(name, 'short', size, default)
def vuint_arr(name:str, size:int, default:Optional[List[int]] = None) -> VariableArray[int]: return VariableArray(name, 'unsigned int', size, default)
def vint_arr(name:str, size:int, default:Optional[List[int]] = None) -> VariableArray[int]: return VariableArray(name, 'int', size, default)
def vulong_arr(name:str, size:int, default:Optional[List[int]] = None) -> VariableArray[int]: return VariableArray(name, 'unsigned long', size, default)
def vlong_arr(name:str, size:int, default:Optional[List[int]] = None) -> VariableArray[int]: return VariableArray(name, 'long', size, default)
def vbool_arr(name:str, size:int, default:Optional[List[bool]] = None) -> VariableArray[bool]: return VariableArray(name, 'bool', size, default)
def vfloat_arr(name:str, size:int, default:Optional[List[float]] = None) -> VariableArray[float]: return VariableArray(name, 'float', size, default)
def vdouble_arr(name:str, size:int, default:Optional[List[float]] = None) -> VariableArray[float]: return VariableArray(name, 'double', size, default)

class BlockType(Enum):
    IF_BLOCK = 0
    WHILE_BLOCK = 1
    FOR_BLOCK = 2
    MACRO_BLOCK = 3

class Macro:
    def __init__(self, name:str, description:Optional[str]=None):
        """A macro definition

        Args:
            name (str): The name of the macro
            description (str, optional): The description of the macro. Defaults to None.
        """
        self.name = name
        self.description = description
        if self.description is None:
            self.description = ""
        self.indentation = 0
        self._maxlen = 200
        self.statements:List[STATEMENT] = []
        self.result:List[str] = ['']
        self.variables:Set[Variable, VariableArray] = set()
        self._nest:deque[BlockType] = deque()
        self._variable_block = VARIABLE_BLOCK()
    
    def __enter__(self) -> Macro:
        self.begin()
        return self
    
    def __exit__(self, _, __, ___):
        self.end()
    
    @overload
    def add_variable(self, var:Variable[DT]) -> Variable[DT]:
        self.variables.add(var)
        return var
        
    def add_variable(self, var:VariableArray[DT]) -> VariableArray[DT]:
        self.variables.add(var)
        return var
    
    def write_raw(self, *values:str):
        """Internal method to write text
        """
        v = ''.join([str(vv) for vv in values])
        for l in v.splitlines():
            l = ''.join(repeat('    ', self.indentation)) + l + '\n'
            if (len(l) + len(self.result[-1])) > self._maxlen:
                self.result.append(l)
            else:
                self.result[-1] += l
    
    def write(self, *statements:STATEMENT):
        """Write statements to the macro

        Args:
            *statements (STATEMENT): Statements to add

        Raises:
            SyntaxError: If a not a statement
        """
        for s in statements:
            if not isinstance(s, STATEMENT):
                raise SyntaxError(f"{s} is not a statement")
        self.statements.extend(statements)
                
    def _open_if(self):
        self._nest.append(BlockType.IF_BLOCK)
        self.indentation += 1
        
    def _close_if(self):
        if len(self._nest) == 0:
            raise SyntaxError('Unable to close if, no if opened.')
        if self._nest[-1] != BlockType.IF_BLOCK:
            raise SyntaxError(f'{self._nest[-1].name} not closed.')
        self._nest.pop()
        self.indentation -= 1
        
    def _open_macro(self):
        self._nest.append(BlockType.MACRO_BLOCK)
        self.indentation += 1
        
    def _close_macro(self):
        if len(self._nest) == 0:
            raise SyntaxError('Unable to close macro, no macro opened.')
        if self._nest[-1] != BlockType.MACRO_BLOCK:
            raise SyntaxError(f'{self._nest[-1].name} not closed.')
        self._nest.pop()
        self.indentation -= 1
        
    def _open_while(self):
        self._nest.append(BlockType.WHILE_BLOCK)
        self.indentation += 1
        
    def _close_while(self):
        if len(self._nest) == 0:
            raise SyntaxError('Unable to close while, no while opened.')
        if self._nest[-1] != BlockType.WHILE_BLOCK:
            raise SyntaxError(f'{self._nest[-1].name} not closed.')
        self._nest.pop()
        self.indentation -= 1
        
    def _open_for(self):
        self._nest.append(BlockType.FOR_BLOCK)
        self.indentation += 1
        
    def _close_for(self):
        if len(self._nest) == 0:
            raise SyntaxError('Unable to close for, no for opened.')
        if self._nest[-1] != BlockType.FOR_BLOCK:
            raise SyntaxError(f'{self._nest[-1].name} not closed.')
        self._nest.pop()
        self.indentation -= 1
        
    def begin(self):
        self.write(
            COMMENT(HEADER),
            EMPTY(),
            EMPTY(),
            COMMENT(self.description),
            BEGIN_MACRO(),
            self._variable_block,
            EMPTY(),
        )
        
    def end(self):
        self.write(END_MACRO())
    
    def display(self, io:TextIO=None):
        """Displays the resulting macro

        Args:
            io (TextIO, optional): Stream to print the macro to. Defaults to stdout.
        """
        self.result = ['']
        for s in self.statements:
            s.process(self)
        
        for s in self.statements:
            s.bake(self)
        
        for l in self.result:
            print(l, end='', file=io)
            
    def clipboard(self):
        """Copies the resulting macro to clipboard
        """
        import pyperclip
        self.result = ['']
        for s in self.statements:
            s.process(self)
        
        for s in self.statements:
            s.bake(self)
        pyperclip.copy(''.join(self.result))
        

class CONDITIONAL(STATEMENT):
    def __init__(self, condition:Union[bool, Callable[[], bool]], 
                 onTrue:List[STATEMENT]=None, onFalse:List[STATEMENT]=None):
        super().__init__()
        self.condition = condition
        self.onTrue = onTrue
        self.onFalse = onFalse
        
    @property
    def result(self) -> bool:
        if callable(self.condition):
            return self.condition()
        return self.condition
        
    def process(self, macro:Macro):
        if self.result:
            if self.onTrue is not None:
                for s in self.onTrue:
                    s.process(macro)
        else:
            if self.onFalse is not None:
                for s in self.onFalse:
                    s.process(macro)
        super().process(macro)
    
    def bake(self, macro:Macro):
        if self.result:
            if self.onTrue is not None:
                for s in self.onTrue:
                    s.bake(macro)
        else:
            if self.onFalse is not None:
                for s in self.onFalse:
                    s.bake(macro)


def C_MIN(a:Union[DT, Variable[DT]], b:Union[DT, Variable[DT]], r:Variable[DT]) -> STATEMENT:
    if isinstance(a, (Variable, VariableItem)):
        return IF(a <= b)(r.set(a)).ELSE()(r.set(b))
    if isinstance(b, (Variable, VariableItem)):
        return IF(b > a)(r.set(a)).ELSE()(r.set(b))
    if a <= b:
        return r.set(a)
    return r.set(b)

def C_MAX(a:Union[DT, Variable[DT]], b:Union[DT, Variable[DT]], r:Variable[DT]) -> STATEMENT:
    if isinstance(a, (Variable, VariableItem)):
        return IF(a > b)(r.set(a)).ELSE()(r.set(b))
    if isinstance(b, (Variable, VariableItem)):
        return IF(b <= a)(r.set(a)).ELSE()(r.set(b))
    if a > b:
        return r.set(a)
    return r.set(b)

AnyVariable = Union[Variable[DT], VariableItem[DT]]
AnyValue = Union[Variable, VariableItem, EXPRESSION, int, bool, float]

AnyBool = Union[Variable[bool], VariableItem[bool], EXPRESSION, bool]
AnyInt = Union[Variable[int], VariableArray[int], EXPRESSION, int]
AnyFloat = Union[Variable[float], VariableItem[float], EXPRESSION, float]
TagAddress = Union[str, Tuple[str, int]]


def string_literal(v:str) -> str:
    """Wraps a str in '"' if needed

    Args:
        v (str): String to wrap

    Returns:
        str: Wrapped string
    """
    if not v.startswith('"'):
        v = '"' + v
    if not v.endswith('"'):
        v += '"'
    return v

def ensure_string_is_literal(v:DT) -> DT:
    """Ensures that if a string is passed, it gets wrapped in '"'

    Args:
        v (DT): Value to process

    Returns:
        DT: Processed value
    """
    if isinstance(v, str):
        return string_literal(v)
    return v
    
def tag_address(addr:TagAddress) -> str:
    if isinstance(addr, str):
        return string_literal(addr)
    if isinstance(addr, tuple):
        return f"{addr[0]}, {addr[1]}"
    raise SyntaxError(f"Invalid address syntax: {addr}")


